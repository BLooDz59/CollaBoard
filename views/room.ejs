<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>CollaBoard</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { font: 13px Helvetica, Arial; }
            #canvas { border: red solid 5px;}
        </style>
    </head>
    <body>
        <canvas id="canvas" width="400" height="400"></canvas>
        <button onclick="undo()"> Undo </button>
        <button onclick="redo()"> Redo </button>
        <button onclick="changeSize(10)"> Size 1 </button>
        <button onclick="changeSize(20)"> Size 2 </button>
        <button onclick="changeColor('red')"> Red </button>
        <button onclick="changeColor('blue')"> Blue </button>
        <script src="/socket.io/socket.io.js"></script>
        <script>
            const socket = io();
            const roomId = "<%= roomId %>"
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            var undoStates = [];
            var redoStates = [];
            var currentState = getCanvasState();

            var isDrawing = false;
            var mouseX = 0;
            var mouseY = 0;
            var penSize = 10;
            var penColor = 'black';
            const bounds = canvas.getBoundingClientRect();

            socket.emit('new-user', roomId);
            socket.emit('synchronize', roomId);

            function changeSize(size) {
                socket.emit('changePenSize', size, roomId);
            }

            function changeColor(color) {
                socket.emit('changePenColor', color, roomId);
            }

            socket.on('changePenSize', (size) => {
                penSize = size;
            });

            socket.on('changePenColor', (color) => {
                penColor = color;
            });

            function undo() {
                if(undoStates.length > 0) {
                    redoStates.push(getCanvasState());
                    var state = undoStates.pop();
                    currentState = state;
                    renderCanvasState(state);
                }
            }

            function redo() {
                if(redoStates.length > 0) {
                    undoStates.push(getCanvasState());
                    var futurState = redoStates.pop();
                    currentState = futurState;
                    renderCanvasState(futurState);
                }
            }

            function renderCanvasState(state) {
                var img = new Image();
                img.src = state;
                img.onload = function() { 
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.drawImage(img,0,0);
                };
            }

            function getCanvasState() {
                return canvas.toDataURL();
            }

            socket.on('request-context', (writerID) => {
                if(socket.id == writerID) {
                    var data = {
                        canvas: canvas.toDataURL(),
                        penColor: penColor,
                        penSize: penSize
                    }
                    socket.emit('context-sending', roomId, data);
                } 
            })
            
            socket.on('context-sending', (data) => {
                renderCanvasState(data.canvas);
                changeSize(data.penSize);
                changeColor(data.penColor);
            });

            socket.on('draw', (data) => {
                ctx.beginPath();
                ctx.ellipse(data.x, data.y, penSize, penSize, 0, 0, 2 * Math.PI);
                ctx.fillStyle = penColor;
                ctx.fill();
                ctx.closePath();
            });

            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                mouseX = e.clientX - bounds.left;
                mouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if(isDrawing) {
                    var data = {
                        x: mouseX,
                        y: mouseY
                    }
                    socket.emit('draw', roomId, data);
                    mouseX = e.clientX - bounds.left;
                    mouseY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if(isDrawing) {
                    var data = {
                        x: mouseX,
                        y: mouseY
                    };
                    socket.emit('draw', roomId, data);
                    isDrawing = false;
                    mouseX = 0;
                    mouseY = 0;
                    undoStates.push(currentState);
                    currentState = getCanvasState();
                }
            });
        </script>
    </body>
</html>